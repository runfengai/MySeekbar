package com.jarry.myseekbar;import android.content.Context;import android.graphics.Canvas;import android.graphics.Color;import android.graphics.Paint;import android.graphics.RectF;import android.graphics.Shader;import android.graphics.SweepGradient;import android.graphics.drawable.Drawable;import android.os.Build;import android.support.annotation.RequiresApi;import android.util.AttributeSet;import android.util.Log;import android.view.MotionEvent;import android.view.View;/** * 两个不同半径的圆相交，去除覆盖部分，保留底层部分，得到月牙形的图片。 */public class MySeekBar extends View {    static final String TAG = "MySeekBar";    Paint paint = new Paint();    //view宽高    int width = 0, height = 0;    //小圆的半径    int radius = 300;    //大圆的半径    double newRadius = 350;    private Drawable mThumb;    public MySeekBar(Context context) {        super(context);        init(context);    }    public MySeekBar(Context context, AttributeSet attrs) {        super(context, attrs);        init(context);    }    public MySeekBar(Context context, AttributeSet attrs, int defStyleAttr) {        super(context, attrs, defStyleAttr);        init(context);    }    @RequiresApi(api = Build.VERSION_CODES.LOLLIPOP)    public MySeekBar(Context context, AttributeSet attrs, int defStyleAttr, int defStyleRes) {        super(context, attrs, defStyleAttr, defStyleRes);        init(context);    }    private void init(Context context) {        mThumb = context.getResources().getDrawable(R.drawable.seek_arc_control_selector);        if (mThumb != null) {            int thumbHalfH = mThumb.getIntrinsicHeight() / 4;            int thumbHalfW = mThumb.getIntrinsicWidth() / 4;            mThumb.setBounds(-thumbHalfW, -thumbHalfH, thumbHalfW, thumbHalfH);        }        paint = new Paint();        paint.setStyle(Paint.Style.FILL);//填充        paint.setAntiAlias(true);// 去除锯齿效果        paint.setDither(true);// 防抖动，会使绘制出来的图片颜色更加平滑和饱满，图像更加清晰    }    int square = 0;    //彩色背景    Shader mShader;    @Override    protected synchronized void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {        super.onMeasure(widthMeasureSpec, heightMeasureSpec);        width = getMeasuredWidth();        height = getMeasuredHeight();        square = Math.min(width, height);        radius = square / 2;        //利用几何知识，计算新半径        newRadius = Math.sqrt((radius / 2) * (radius / 2) + (radius + radius * Math.sqrt(3) / 2) * (radius + radius * Math.sqrt(3) / 2));        startX = radius / 2;        startY = (float) ((1 + Math.sqrt(3) / 2) * radius);        //将按钮点添加到范围内，控制touch事件，可以来回滑动        thumbMaxAngle = (float) (2 * Math.atan(radius / 2 / (startY - radius / 2)));        thumbStartAngle = (float) (Math.PI / 2 - thumbMaxAngle / 2);        thumbEndAngle = (float) (Math.PI / 2 + thumbMaxAngle / 2);        angle = thumbEndAngle;        thumbRadius = radius / 2 / Math.sin(thumbMaxAngle / 2);        //初始化轨迹球弧形中心坐标        thumbCenterY = radius / 2;        rectF1= new RectF(0, 0, square, square);        rectF2 = new RectF((int) (radius - newRadius), (int) -newRadius, (int) (radius + newRadius), (int) newRadius);        mShader= new SweepGradient(radius, radius,                new int[]{Color.RED, Color.GREEN, Color.BLUE, Color.RED, Color.GREEN, Color.BLUE,                        Color.RED, Color.GREEN, Color.BLUE, Color.RED, Color.GREEN, Color.BLUE,                        Color.RED, Color.GREEN, Color.BLUE, Color.RED, Color.GREEN, Color.BLUE}, null);    }    //按钮的起始位置    float startX;    float startY;    /**     * 按钮的轨迹方程可以通过半径和角度angle获取     */    double thumbRadius = 0;    float angle;//根据角度计算按钮轨迹    float thumbMaxAngle = 0;//按钮可旋转最大角度    float thumbStartAngle = 0, thumbEndAngle = 0;    float thumbCenterY = 0;    //小圆、大圆半径    RectF rectF1 ,rectF2;    @Override    protected synchronized void onDraw(Canvas canvas) {//        super.onDraw(canvas);        paint.setShader(mShader);        //先绘制外层小圆弧        canvas.drawArc(rectF1, 60, 60, true, paint);        paint.setShader(null);        paint.setColor(Color.WHITE);        //绘制里层大圆弧        canvas.drawArc(rectF2, 75, 30, true, paint);        paint.setShader(null);        //根据当前移动坐标计算旋钮的所在点，并绘制        canvas.translate((float) (radius + thumbRadius * Math.cos(angle)), (float) (thumbCenterY + thumbRadius * Math.sin(angle)));        mThumb.draw(canvas);    }    float touchStartX = 0, touchStartY = 0;    @Override    public boolean onTouchEvent(MotionEvent event) {        switch (event.getAction()) {            case MotionEvent.ACTION_DOWN:                setPressed(true);                touchStartX = event.getX();                touchStartY = event.getY();                break;            case MotionEvent.ACTION_MOVE:                float endX = event.getX();                float endY = event.getY();                float moveX = endX - touchStartX;                float tmp = moveX / radius * thumbMaxAngle;                if (angle - tmp > thumbEndAngle)                    angle = thumbEndAngle;                else if (angle - tmp < thumbStartAngle)                    angle = thumbStartAngle;                else angle -= tmp;                touchStartX = endX;                touchStartY = endY;                invalidate();                break;            case MotionEvent.ACTION_UP:            case MotionEvent.ACTION_CANCEL:                setPressed(false);                break;        }        return true;    }    @Override    protected void drawableStateChanged() {        super.drawableStateChanged();        if (mThumb != null && mThumb.isStateful()) {            int[] state = getDrawableState();            mThumb.setState(state);        }        invalidate();    }}